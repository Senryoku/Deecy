// Takes a list of fragment generated by rendering a closed translucent modifier volume and
// add them to the list of already rendered segments, merging them if necessary.

struct Heads {
  fragment_count: u32,
  data: array<u32>
};

@group(0) @binding(0) var<uniform> oit_uniforms: OITUniforms;
@group(0) @binding(1) var<storage, read_write> modvol_heads: Heads;
@group(0) @binding(2) var<storage, read_write> modvol_linked_list: VolumeLinkedList;
@group(0) @binding(3) var<storage, read_write> previous_modvols: array<Volumes>;


@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let heads_index = global_id.y * oit_uniforms.target_width + global_id.x;

    var modvol_index = modvol_heads.data[heads_index];
    // Reset the heads buffer for the next pass.
    modvol_heads.data[heads_index] = 0xFFFFFFFFu;
    if all(global_id == vec3<u32>(0, 0, 0)) {
        modvol_heads.fragment_count = 0;
    }

    var modvol: array<f32, MaxVolumesInterfaces>;
    var modvol_count = 0u;
    // Sort the Modifier Volume fragments
    while modvol_index != 0xFFFFFFFFu && modvol_count < MaxVolumesInterfaces {
        modvol[modvol_count] = modvol_linked_list.data[modvol_index].depth;
        modvol_index = modvol_linked_list.data[modvol_index].next;

        let to_insert = modvol[modvol_count];
        var j = modvol_count;

        // Look back into the sorted array until we find where we should insert the new fragment, moving up previous fragment as needed.
        while j > 0u && (to_insert < modvol[j - 1u]) {
            modvol[j] = modvol[j - 1u];
            j--;
        }

        modvol[j] = to_insert;

        modvol_count++;
    }

    var new_volumes = Volumes();
    new_volumes.count = modvol_count / 2;
    for (var i = 0u; i < new_volumes.count; i++) {
        new_volumes.intervals[i] = vec2<f32>(modvol[2 * i], modvol[2 * i + 1]);
    }
    if modvol_count % 2 == 1 { // Last volume is open (backside behind the depth plane)
        new_volumes.intervals[new_volumes.count] = vec2<f32>(modvol[2 * new_volumes.count], 10.0);
        new_volumes.count++;
	}

    if new_volumes.count == 0 {
		// Nothing to do!
        return;
    }

    previous_modvols[heads_index] = volume_union(new_volumes, previous_modvols[heads_index]);
}

fn volume_union(a: Volumes, b: Volumes) -> Volumes {
    if a.count == 0 { return b; }
    if b.count == 0 { return a; }

    var union_volumes = Volumes();

	// Insert and Merge volumes
    var a_index = 0u;
    var b_index = 0u;
    if a.intervals[0].x < b.intervals[0].x {
        union_volumes.intervals[0] = a.intervals[0];
        a_index++;
    } else {
        union_volumes.intervals[0] = b.intervals[0];
        b_index++;
    }
    union_volumes.count = 1u;

    var to_insert: vec2<f32>;
    while a_index < a.count || b_index < b.count {
        if a_index >= a.count {
            to_insert = b.intervals[b_index];
            b_index++;
        } else if b_index >= b.count {
            to_insert = a.intervals[a_index];
            a_index++;
        } else {
            if a.intervals[a_index].x < b.intervals[b_index].x {
                to_insert = a.intervals[a_index];
                a_index++;
            } else {
                to_insert = b.intervals[b_index];
                b_index++;
            }
        }

        if to_insert.x <= union_volumes.intervals[union_volumes.count - 1].y {
			// Merge
            union_volumes.intervals[union_volumes.count - 1].y = max(to_insert.y, union_volumes.intervals[union_volumes.count - 1].y);
        } else {
            union_volumes.intervals[union_volumes.count] = to_insert;
            union_volumes.count++;
        }

        if union_volumes.count >= MaxVolumes {
            return union_volumes;
        }
    }

    return union_volumes;
} 