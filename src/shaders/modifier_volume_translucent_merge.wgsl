// Takes a list of fragments generated by rendering translucent modifier volumes and
// consolidate them into a list of volumes.

@group(0) @binding(0) var<uniform> oit_tmv_uniforms: OITTMVUniforms;
@group(0) @binding(1) var<storage, read_write> modvol_fragment_counts: array<u32>;
@group(0) @binding(2) var<storage, read_write> modvol_fragment_list: VolumeFragmentList;
@group(0) @binding(3) var<storage, read_write> out_modvols: array<StoredVolumes>;

struct VolumeLinkedListElementData {
    volume_index: u32,
    depth: f32,
};

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let pixel_index = slice_coords_to_pixel_index(oit_tmv_uniforms, global_id.xy);

    let frag_count = min(MaxVolumeFragments, modvol_fragment_counts[pixel_index]);

    var volumes = Volumes();
    volumes.count = 0;

    if frag_count > 0u {
        // Group the Modifier Volume fragments by volume and sort by depth.
        var fragments: array<VolumeLinkedListElementData, MaxVolumeFragments>;
        for(var i = 0u; i < frag_count; i++) {
            let index =  tmv_fragment_index(oit_tmv_uniforms, pixel_index, i);

            let node = modvol_fragment_list.data[index];
            var to_insert = VolumeLinkedListElementData(node[0], bitcast<f32>(node[1]));

            var j = i;

            // Look back into the sorted array until we find where we should insert the new fragment, moving up previous fragment as needed.
            while j > 0u && (to_insert.volume_index < fragments[j - 1u].volume_index || (to_insert.volume_index == fragments[j - 1u].volume_index && to_insert.depth < fragments[j - 1u].depth)) {
                fragments[j] = fragments[j - 1u];
                j--;
            }

            fragments[j] = to_insert;
        }

        var curr_fragment = 0u;

        // Insert first interval now to avoid having to deal with the empty case later.
        var first_volume_frag_count = 1u;
        var first_volume_index = fragments[0].volume_index;
        while first_volume_frag_count < frag_count && fragments[first_volume_frag_count].volume_index == first_volume_index { first_volume_frag_count++; }

        volumes.count = 1u;
        if (first_volume_frag_count & 1u) == 1 {
            volumes.intervals[0] = vec2<f32>(0.0, fragments[0].depth);
            curr_fragment = 1u;
        } else {
            volumes.intervals[0] = vec2<f32>(fragments[0].depth, fragments[1].depth);
            curr_fragment = 2u;
        }

        for (var i = curr_fragment; i < first_volume_frag_count; i += 2) {
            volumes = insert_interval(volumes, vec2<f32>(fragments[i].depth, fragments[i + 1].depth));
        }
        curr_fragment = first_volume_frag_count;

        while curr_fragment < frag_count {
            let start_fragment = curr_fragment;
            let curr_volume = fragments[start_fragment].volume_index;
            curr_fragment++;
            while curr_fragment < frag_count && fragments[curr_fragment].volume_index == curr_volume { curr_fragment++; }
            let fragment_count = curr_fragment - start_fragment;

            // Convert the sorted list of depth values into a list of intervals and merge them into our current volumes.
            if (fragment_count & 1u) == 1 { // Last volume is open (backside behind the depth plane)
                volumes = insert_interval(volumes, vec2<f32>(0.0, fragments[start_fragment].depth));
            }
            for (var i = (fragment_count & 1u); i < fragment_count; i += 2) {
                volumes = insert_interval(volumes, vec2<f32>(fragments[start_fragment + i].depth, fragments[start_fragment + i + 1].depth));
            }
        }
    }

    // Mark other volumes as unused
    for(var i = volumes.count; i < MaxVolumes; i++) {
        volumes.intervals[i] = vec2<f32>(-1.0);
    }
    out_modvols[global_id.y * oit_tmv_uniforms.target_width + global_id.x].intervals = volumes.intervals;

    // Reset the heads buffer for the next pass.
    modvol_fragment_counts[pixel_index] = 0u;
}

fn insert_interval(a: Volumes, interval: vec2<f32>) -> Volumes {
    var union_volumes = Volumes();
    union_volumes.count = 0u;

    // NOTE: We known a isn't empty here.
    // if a.count == 0 { 
    //     union_volumes.intervals[0] = interval;
    //     union_volumes.count = 1u;
    //     return union_volumes;
    // }

    while(union_volumes.count < a.count && a.intervals[union_volumes.count].x < interval.x) {
        union_volumes.intervals[union_volumes.count] = a.intervals[union_volumes.count];
        union_volumes.count++;
    }
    let appended_intervals = union_volumes.count;
    union_volumes = append_interval(union_volumes, interval);
    for(var i = appended_intervals; i < a.count; i++) {
        union_volumes = append_interval(union_volumes, a.intervals[i]);
    }
    return union_volumes;
} 

fn append_interval(a: Volumes, interval: vec2<f32>) -> Volumes {
    var union_volumes = Volumes();
    union_volumes.count = a.count;
    union_volumes.intervals = a.intervals;
    if(interval.x > union_volumes.intervals[union_volumes.count - 1u].y) {
        union_volumes.intervals[union_volumes.count] = interval;
        union_volumes.count++;
    } else {
        union_volumes.intervals[union_volumes.count - 1u].y = max(union_volumes.intervals[union_volumes.count - 1u].y, interval.y);
    }
    return union_volumes;
}