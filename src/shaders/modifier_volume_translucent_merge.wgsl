// Takes a list of fragments generated by rendering translucent modifier volumes and
// consolidate them into a list of volumes.

@group(0) @binding(0) var<uniform> oit_tmv_uniforms: OITTMVUniforms;
@group(0) @binding(1) var<storage, read_write> modvol_fragment_counts: array<u32>;
@group(0) @binding(2) var<storage, read_write> modvol_fragment_list: VolumeFragmentList;
@group(0) @binding(3) var<storage, read_write> out_modvols: array<StoredVolumes>;

struct VolumeLinkedListElementData {
    volume_index: u32,
    depth: f32,
};

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
    let pixel_index = slice_coords_to_pixel_index(oit_tmv_uniforms, global_id.xy);

    let frag_count = min(MaxVolumeFragments, modvol_fragment_counts[pixel_index]);
    var sorted_frag_count = 0u;

    // Group the Modifier Volume fragments by volume and sort by depth.
    var fragments: array<VolumeLinkedListElementData, MaxVolumeFragments>;
    for(var i = 0u; i < frag_count; i++) {
        let index =  tmv_fragment_index(oit_tmv_uniforms, pixel_index, i);

        let node = modvol_fragment_list.data[index];
        var to_insert = VolumeLinkedListElementData(node[0], bitcast<f32>(node[1]));

        var j = sorted_frag_count;

        // Look back into the sorted array until we find where we should insert the new fragment, moving up previous fragment as needed.
        while j > 0u && (to_insert.volume_index < fragments[j - 1u].volume_index || (to_insert.volume_index == fragments[j - 1u].volume_index && to_insert.depth < fragments[j - 1u].depth)) {
            fragments[j] = fragments[j - 1u];
            j--;
        }

        fragments[j] = to_insert;

        sorted_frag_count++;
    }

    var volumes = Volumes();
    volumes.count = 0;

    var curr_fragment = 0u;
    while curr_fragment < frag_count {
        let start_fragment = curr_fragment;
        let curr_volume = fragments[start_fragment].volume_index;
        curr_fragment++;
        while curr_fragment < frag_count && fragments[curr_fragment].volume_index == curr_volume {
            curr_fragment++;
        }
        let fragment_count = curr_fragment - start_fragment;

        // Convert the sorted list of depth values into a list of intervals
        var new_volumes = Volumes();
        new_volumes.count = fragment_count / 2;
        for (var i = 0u; i < new_volumes.count; i++) {
            new_volumes.intervals[i] = vec2<f32>(fragments[start_fragment + 2 * i].depth, fragments[start_fragment + 2 * i + 1].depth);
        }
        if fragment_count % 2 == 1 { // Last volume is open (backside behind the depth plane)
            new_volumes.intervals[new_volumes.count] = vec2<f32>(fragments[start_fragment + 2 * new_volumes.count].depth, 10.0);
            new_volumes.count++;
	    }

        volumes = volume_union(new_volumes, volumes);
    }

    // Mark other volumes as unused
    for(var i = volumes.count; i < MaxVolumes; i++) {
        volumes.intervals[i] = vec2<f32>(-1.0);
    }
    out_modvols[global_id.y * oit_tmv_uniforms.target_width + global_id.x].intervals = volumes.intervals;

    // Reset the heads buffer for the next pass.
    modvol_fragment_counts[pixel_index] = 0u;
}

fn volume_union(a: Volumes, b: Volumes) -> Volumes {
    if a.count == 0 { return b; }
    if b.count == 0 { return a; }

    var union_volumes = Volumes();

	// Insert and Merge volumes
    var a_index = 0u;
    var b_index = 0u;
    if a.intervals[0].x < b.intervals[0].x {
        union_volumes.intervals[0] = a.intervals[0];
        a_index++;
    } else {
        union_volumes.intervals[0] = b.intervals[0];
        b_index++;
    }
    union_volumes.count = 1u;

    var to_insert: vec2<f32>;
    while a_index < a.count || b_index < b.count {
        if a_index >= a.count {
            to_insert = b.intervals[b_index];
            b_index++;
        } else if b_index >= b.count {
            to_insert = a.intervals[a_index];
            a_index++;
        } else {
            if a.intervals[a_index].x < b.intervals[b_index].x {
                to_insert = a.intervals[a_index];
                a_index++;
            } else {
                to_insert = b.intervals[b_index];
                b_index++;
            }
        }

        if to_insert.x <= union_volumes.intervals[union_volumes.count - 1].y {
			// Merge
            union_volumes.intervals[union_volumes.count - 1].y = max(to_insert.y, union_volumes.intervals[union_volumes.count - 1].y);
        } else {
            union_volumes.intervals[union_volumes.count] = to_insert;
            union_volumes.count++;
            if union_volumes.count >= MaxVolumes {
                return union_volumes;
            }
        }
    }

    return union_volumes;
} 